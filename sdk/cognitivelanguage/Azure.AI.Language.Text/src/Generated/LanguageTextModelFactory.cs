// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.AI.Language.Text
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class LanguageTextModelFactory
    {
        /// <summary>
        /// Collection of documents to analyze and a single task to execute.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.TextEntityLinkingInput"/>, <see cref="Text.TextEntityRecognitionInput"/>, <see cref="Text.TextKeyPhraseExtractionInput"/>, <see cref="Text.TextLanguageDetectionInput"/>, <see cref="Text.TextPiiEntitiesRecognitionInput"/>, and <see cref="Text.TextSentimentAnalysisInput"/>.
        /// </summary>
        /// <param name="kind"> The kind of task to perform. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextInput"/> instance for mocking. </returns>
        public static AnalyzeTextInput AnalyzeTextInput(string kind = default)
        {
            return new UnknownAnalyzeTextInput(new AnalyzeTextInputKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text Entity linking input. </summary>
        /// <param name="textInput"> Contains the analysis input to be handled by the service. </param>
        /// <param name="actionContent"> Task parameters. </param>
        /// <returns> A new <see cref="Text.TextEntityLinkingInput"/> instance for mocking. </returns>
        public static TextEntityLinkingInput TextEntityLinkingInput(MultiLanguageTextInput textInput = default, EntityLinkingActionContent actionContent = default)
        {
            return new TextEntityLinkingInput(AnalyzeTextInputKind.EntityLinking, additionalBinaryDataProperties: null, textInput, actionContent);
        }

        /// <summary> Collection of input documents to be analyzed by the service. </summary>
        /// <param name="multiLanguageInputs"> The input documents to be analyzed. </param>
        /// <returns> A new <see cref="Text.MultiLanguageTextInput"/> instance for mocking. </returns>
        public static MultiLanguageTextInput MultiLanguageTextInput(IEnumerable<MultiLanguageInput> multiLanguageInputs = default)
        {
            multiLanguageInputs ??= new ChangeTrackingList<MultiLanguageInput>();

            return new MultiLanguageTextInput(multiLanguageInputs.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains an input document to be analyzed by the service. </summary>
        /// <param name="id"> A unique, non-empty document identifier. </param>
        /// <param name="text"> The input text to process. </param>
        /// <param name="language"> (Optional) This is the 2 letter ISO 639-1 representation of a language. For example, use \"en\" for English; \"es\" for Spanish etc. If not set, use \"en\" for English as default. (Following only applies to 2023-04-15-preview and above) For Auto Language Detection, use \"auto\". If not set, use \"en\" for English as default. </param>
        /// <returns> A new <see cref="Text.MultiLanguageInput"/> instance for mocking. </returns>
        public static MultiLanguageInput MultiLanguageInput(string id = default, string text = default, string language = default)
        {
            return new MultiLanguageInput(id, text, language, additionalBinaryDataProperties: null);
        }

        /// <summary> Supported parameters for an Entity Linking task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="stringIndexType"> Optional parameter to provide the string index type used to interpret string offsets. Defaults to TextElements (Graphemes). </param>
        /// <returns> A new <see cref="Text.EntityLinkingActionContent"/> instance for mocking. </returns>
        public static EntityLinkingActionContent EntityLinkingActionContent(bool? loggingOptOut = default, string modelVersion = default, StringIndexType? stringIndexType = default)
        {
            return new EntityLinkingActionContent(loggingOptOut, modelVersion, stringIndexType, additionalBinaryDataProperties: null);
        }

        /// <summary> The entity recognition analyze text input task request. </summary>
        /// <param name="textInput"> The input to be analyzed. </param>
        /// <param name="actionContent"> Task parameters. </param>
        /// <returns> A new <see cref="Text.TextEntityRecognitionInput"/> instance for mocking. </returns>
        public static TextEntityRecognitionInput TextEntityRecognitionInput(MultiLanguageTextInput textInput = default, EntitiesActionContent actionContent = default)
        {
            return new TextEntityRecognitionInput(AnalyzeTextInputKind.EntityRecognition, additionalBinaryDataProperties: null, textInput, actionContent);
        }

        /// <summary> Supported parameters for an Entity Recognition task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="stringIndexType"> (Optional) parameter to provide the string index type used to interpret string offsets. Defaults to TextElements (Graphemes). </param>
        /// <param name="inclusions"> (Optional) request parameter that limits the output to the requested entity types included in this list. We will apply inclusionList before exclusionList. </param>
        /// <param name="exclusions"> (Optional) request parameter that filters out any entities that are included the excludeList. When a user specifies an excludeList, they cannot get a prediction returned with an entity in that list. We will apply inclusionList before exclusionList. </param>
        /// <param name="overlapPolicy"> (Optional) describes the type of overlap policy to apply to the ner output. </param>
        /// <param name="inferenceOptions"> (Optional) request parameter that allows the user to provide settings for running the inference. </param>
        /// <returns> A new <see cref="Text.EntitiesActionContent"/> instance for mocking. </returns>
        public static EntitiesActionContent EntitiesActionContent(bool? loggingOptOut = default, string modelVersion = default, StringIndexType? stringIndexType = default, IEnumerable<EntityCategory> inclusions = default, IEnumerable<EntityCategory> exclusions = default, EntityOverlapPolicy overlapPolicy = default, EntityInferenceConfig inferenceOptions = default)
        {
            inclusions ??= new ChangeTrackingList<EntityCategory>();
            exclusions ??= new ChangeTrackingList<EntityCategory>();

            return new EntitiesActionContent(
                loggingOptOut,
                modelVersion,
                stringIndexType,
                inclusions.ToList(),
                exclusions.ToList(),
                overlapPolicy,
                inferenceOptions,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The abstract base class for entity OverlapPolicy.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.MatchLongestEntityPolicyType"/> and <see cref="Text.AllowOverlapEntityPolicyType"/>.
        /// </summary>
        /// <param name="policyKind"> The entity OverlapPolicy object kind. </param>
        /// <returns> A new <see cref="Text.EntityOverlapPolicy"/> instance for mocking. </returns>
        public static EntityOverlapPolicy EntityOverlapPolicy(string policyKind = default)
        {
            return new UnknownEntityOverlapPolicy(new PolicyKind(policyKind), additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the Match longest overlap policy. No overlapping entities as far as it is possible. 1. If there are overlapping entities, the longest one will be returned. 2. If the set of characters predicted for 2 or more entities are exactly the same, select the entity that has the higher confidence score.3. If the entity scores are identical, return all entities that are still present after applying the previous rules. 3. If there is partial overlap (as in Hello Text Analytics) follow the above steps starting from 1. </summary>
        /// <returns> A new <see cref="Text.MatchLongestEntityPolicyType"/> instance for mocking. </returns>
        public static MatchLongestEntityPolicyType MatchLongestEntityPolicyType()
        {
            return new MatchLongestEntityPolicyType(PolicyKind.MatchLongest, additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the allow overlap policy. Will apply no post processing logic for the entities. Whatever the model predicts is what will be returned to the user. This allows the user to get a full view of every single model's possible values and apply their own custom logic on entity selection. </summary>
        /// <returns> A new <see cref="Text.AllowOverlapEntityPolicyType"/> instance for mocking. </returns>
        public static AllowOverlapEntityPolicyType AllowOverlapEntityPolicyType()
        {
            return new AllowOverlapEntityPolicyType(PolicyKind.AllowOverlap, additionalBinaryDataProperties: null);
        }

        /// <summary> The class that houses the inference options allowed for named entity recognition. </summary>
        /// <param name="excludeNormalizedValues"> Option to include/exclude the detected entity values to be normalized and included in the metadata. The numeric and temporal entity types support value normalization. </param>
        /// <returns> A new <see cref="Text.EntityInferenceConfig"/> instance for mocking. </returns>
        public static EntityInferenceConfig EntityInferenceConfig(bool? excludeNormalizedValues = default)
        {
            return new EntityInferenceConfig(excludeNormalizedValues, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text KeyPhraseExtraction task input. </summary>
        /// <param name="textInput"> Contains the input documents. </param>
        /// <param name="actionContent"> Key phrase extraction task parameters. </param>
        /// <returns> A new <see cref="Text.TextKeyPhraseExtractionInput"/> instance for mocking. </returns>
        public static TextKeyPhraseExtractionInput TextKeyPhraseExtractionInput(MultiLanguageTextInput textInput = default, KeyPhraseActionContent actionContent = default)
        {
            return new TextKeyPhraseExtractionInput(AnalyzeTextInputKind.KeyPhraseExtraction, additionalBinaryDataProperties: null, textInput, actionContent);
        }

        /// <summary> Supported parameters for a Key Phrase Extraction task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <returns> A new <see cref="Text.KeyPhraseActionContent"/> instance for mocking. </returns>
        public static KeyPhraseActionContent KeyPhraseActionContent(bool? loggingOptOut = default, string modelVersion = default)
        {
            return new KeyPhraseActionContent(loggingOptOut, modelVersion, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the language detection document analysis task input. </summary>
        /// <param name="textInput"> Documents to be analyzed. </param>
        /// <param name="actionContent"> task parameters. </param>
        /// <returns> A new <see cref="Text.TextLanguageDetectionInput"/> instance for mocking. </returns>
        public static TextLanguageDetectionInput TextLanguageDetectionInput(LanguageDetectionTextInput textInput = default, LanguageDetectionActionContent actionContent = default)
        {
            return new TextLanguageDetectionInput(AnalyzeTextInputKind.LanguageDetection, additionalBinaryDataProperties: null, textInput, actionContent);
        }

        /// <summary> Contains the language detection document analysis input. </summary>
        /// <param name="languageInputs"> List of documents to be analyzed. </param>
        /// <returns> A new <see cref="Text.LanguageDetectionTextInput"/> instance for mocking. </returns>
        public static LanguageDetectionTextInput LanguageDetectionTextInput(IEnumerable<LanguageInput> languageInputs = default)
        {
            languageInputs ??= new ChangeTrackingList<LanguageInput>();

            return new LanguageDetectionTextInput(languageInputs.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the language detection input. </summary>
        /// <param name="id"> A unique, non-empty document identifier. </param>
        /// <param name="text"> The input text to process. </param>
        /// <param name="countryHint"> The country hint to help with language detection of the text. </param>
        /// <returns> A new <see cref="Text.LanguageInput"/> instance for mocking. </returns>
        public static LanguageInput LanguageInput(string id = default, string text = default, string countryHint = default)
        {
            return new LanguageInput(id, text, countryHint, additionalBinaryDataProperties: null);
        }

        /// <summary> Supported parameters for a Language Detection task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <returns> A new <see cref="Text.LanguageDetectionActionContent"/> instance for mocking. </returns>
        public static LanguageDetectionActionContent LanguageDetectionActionContent(bool? loggingOptOut = default, string modelVersion = default)
        {
            return new LanguageDetectionActionContent(loggingOptOut, modelVersion, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text PIIEntityRecognition task input. </summary>
        /// <param name="textInput"> Contains the input documents. </param>
        /// <param name="actionContent"> Pii task parameters. </param>
        /// <returns> A new <see cref="Text.TextPiiEntitiesRecognitionInput"/> instance for mocking. </returns>
        public static TextPiiEntitiesRecognitionInput TextPiiEntitiesRecognitionInput(MultiLanguageTextInput textInput = default, PiiActionContent actionContent = default)
        {
            return new TextPiiEntitiesRecognitionInput(AnalyzeTextInputKind.PiiEntityRecognition, additionalBinaryDataProperties: null, textInput, actionContent);
        }

        /// <summary> Supported parameters for a PII Entities Recognition task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="domain"> Domain for PII task. </param>
        /// <param name="piiCategories"> Enumeration of PII categories to be returned in the response. </param>
        /// <param name="stringIndexType"> StringIndexType to be used for analysis. </param>
        /// <param name="excludePiiCategories"> Enumeration of PII categories to be excluded in the response. </param>
        /// <param name="valueExclusionPolicy"> Policy for specific words and terms that should be excluded from detection by the PII detection service. </param>
        /// <param name="entitySynonyms"> (Optional) request parameter that allows the user to provide synonyms for context words that to enhance pii entity detection. </param>
        /// <param name="redactionPolicies"> List of RedactionPolicies to be used on the input. </param>
        /// <param name="confidenceScoreThreshold"> Confidence score threshold configuration for PII entity recognition. </param>
        /// <param name="disableEntityValidation"> Disable entity validation for PII entity recognition. </param>
        /// <returns> A new <see cref="Text.PiiActionContent"/> instance for mocking. </returns>
        public static PiiActionContent PiiActionContent(bool? loggingOptOut = default, string modelVersion = default, PiiDomain? domain = default, IEnumerable<PiiCategory> piiCategories = default, StringIndexType? stringIndexType = default, IEnumerable<PiiCategoriesExclude> excludePiiCategories = default, ValueExclusionPolicy valueExclusionPolicy = default, IEnumerable<EntitySynonyms> entitySynonyms = default, IEnumerable<BaseRedactionPolicy> redactionPolicies = default, ConfidenceScoreThreshold confidenceScoreThreshold = default, bool? disableEntityValidation = default)
        {
            piiCategories ??= new ChangeTrackingList<PiiCategory>();
            excludePiiCategories ??= new ChangeTrackingList<PiiCategoriesExclude>();
            entitySynonyms ??= new ChangeTrackingList<EntitySynonyms>();
            redactionPolicies ??= new ChangeTrackingList<BaseRedactionPolicy>();

            return new PiiActionContent(
                loggingOptOut,
                modelVersion,
                domain,
                piiCategories.ToList(),
                stringIndexType,
                excludePiiCategories.ToList(),
                valueExclusionPolicy,
                entitySynonyms.ToList(),
                redactionPolicies.ToList(),
                confidenceScoreThreshold,
                disableEntityValidation,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Policy for specific words and terms that should be excluded from detection by the PII detection service. </summary>
        /// <param name="caseSensitive"> Option to make the values excluded values case sensitive. </param>
        /// <param name="excludedValues"> List of words and terms that should be excluded from detection by the PII detection service. </param>
        /// <returns> A new <see cref="Text.ValueExclusionPolicy"/> instance for mocking. </returns>
        public static ValueExclusionPolicy ValueExclusionPolicy(bool caseSensitive = default, IEnumerable<string> excludedValues = default)
        {
            excludedValues ??= new ChangeTrackingList<string>();

            return new ValueExclusionPolicy(caseSensitive, excludedValues.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Object that allows the user to provide synonyms for context words that to enhance pii entity detection. </summary>
        /// <param name="entityType"> The entity name. </param>
        /// <param name="synonyms"> The entity synonyms. </param>
        /// <returns> A new <see cref="Text.EntitySynonyms"/> instance for mocking. </returns>
        public static EntitySynonyms EntitySynonyms(EntityCategory entityType = default, IEnumerable<EntitySynonym> synonyms = default)
        {
            synonyms ??= new ChangeTrackingList<EntitySynonym>();

            return new EntitySynonyms(entityType, synonyms.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The entity synonyms used to enhance pii entity detection. </summary>
        /// <param name="synonym"> The synonym to be used for context. </param>
        /// <param name="language"> The 2 letter ISO 639-1 language the synonym. </param>
        /// <returns> A new <see cref="Text.EntitySynonym"/> instance for mocking. </returns>
        public static EntitySynonym EntitySynonym(string synonym = default, string language = default)
        {
            return new EntitySynonym(synonym, language, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The abstract base class for RedactionPolicy.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.CharacterMaskPolicyType"/>, <see cref="Text.SyntheticReplacementPolicyType"/>, <see cref="Text.NoMaskPolicyType"/>, and <see cref="Text.EntityMaskPolicyType"/>.
        /// </summary>
        /// <param name="policyKind"> The entity RedactionPolicy object kind. </param>
        /// <param name="entityTypes"> (Optional) describes the PII categories to which the redaction policy will be applied. If not specified, the redaction policy will be applied to all PII categories. </param>
        /// <param name="policyName"> (Optional) name of the redaction policy for identification purposes. </param>
        /// <param name="isDefaultPolicy"> (Optional) flag to indicate whether this redaction policy is the default policy to be applied when no specific policy is defined for a PII category. Only one policy can be marked as default. </param>
        /// <returns> A new <see cref="Text.BaseRedactionPolicy"/> instance for mocking. </returns>
        public static BaseRedactionPolicy BaseRedactionPolicy(string policyKind = default, IEnumerable<PiiCategoriesExclude> entityTypes = default, string policyName = default, bool? isDefaultPolicy = default)
        {
            entityTypes ??= new ChangeTrackingList<PiiCategoriesExclude>();

            return new UnknownBaseRedactionPolicy(new RedactionPolicyKind(policyKind), entityTypes.ToList(), policyName, isDefaultPolicy, additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the policy of redacting with a redaction character. </summary>
        /// <param name="entityTypes"> (Optional) describes the PII categories to which the redaction policy will be applied. If not specified, the redaction policy will be applied to all PII categories. </param>
        /// <param name="policyName"> (Optional) name of the redaction policy for identification purposes. </param>
        /// <param name="isDefaultPolicy"> (Optional) flag to indicate whether this redaction policy is the default policy to be applied when no specific policy is defined for a PII category. Only one policy can be marked as default. </param>
        /// <param name="redactionCharacter"> Optional parameter to use a Custom Character to be used for redaction in PII responses. Default character will bce * as before. We allow specific ascii characters for redaction. </param>
        /// <param name="unmaskLength"> Optional parameter to indicate the length of unmasked characters at the end of the redacted PII entity. Default is 0. </param>
        /// <param name="unmaskFromEnd"> Optional parameter to indicate whether to unmask characters from the end of the redacted PII entity. Default is true. </param>
        /// <returns> A new <see cref="Text.CharacterMaskPolicyType"/> instance for mocking. </returns>
        public static CharacterMaskPolicyType CharacterMaskPolicyType(IEnumerable<PiiCategoriesExclude> entityTypes = default, string policyName = default, bool? isDefaultPolicy = default, RedactionCharacter? redactionCharacter = default, int? unmaskLength = default, bool? unmaskFromEnd = default)
        {
            entityTypes ??= new ChangeTrackingList<PiiCategoriesExclude>();

            return new CharacterMaskPolicyType(
                RedactionPolicyKind.CharacterMask,
                entityTypes.ToList(),
                policyName,
                isDefaultPolicy,
                additionalBinaryDataProperties: null,
                redactionCharacter,
                unmaskLength,
                unmaskFromEnd);
        }

        /// <summary> Represents the policy of replacing detected PII with synthetic values. </summary>
        /// <param name="entityTypes"> (Optional) describes the PII categories to which the redaction policy will be applied. If not specified, the redaction policy will be applied to all PII categories. </param>
        /// <param name="policyName"> (Optional) name of the redaction policy for identification purposes. </param>
        /// <param name="isDefaultPolicy"> (Optional) flag to indicate whether this redaction policy is the default policy to be applied when no specific policy is defined for a PII category. Only one policy can be marked as default. </param>
        /// <param name="preserveDataFormat"> Optional flag to indicate whether to preserve the original data format in the synthetic replacement. Default is false. </param>
        /// <returns> A new <see cref="Text.SyntheticReplacementPolicyType"/> instance for mocking. </returns>
        public static SyntheticReplacementPolicyType SyntheticReplacementPolicyType(IEnumerable<PiiCategoriesExclude> entityTypes = default, string policyName = default, bool? isDefaultPolicy = default, bool? preserveDataFormat = default)
        {
            entityTypes ??= new ChangeTrackingList<PiiCategoriesExclude>();

            return new SyntheticReplacementPolicyType(
                RedactionPolicyKind.SyntheticReplacement,
                entityTypes.ToList(),
                policyName,
                isDefaultPolicy,
                additionalBinaryDataProperties: null,
                preserveDataFormat);
        }

        /// <summary> Represents the policy of not redacting found PII. </summary>
        /// <param name="entityTypes"> (Optional) describes the PII categories to which the redaction policy will be applied. If not specified, the redaction policy will be applied to all PII categories. </param>
        /// <param name="policyName"> (Optional) name of the redaction policy for identification purposes. </param>
        /// <param name="isDefaultPolicy"> (Optional) flag to indicate whether this redaction policy is the default policy to be applied when no specific policy is defined for a PII category. Only one policy can be marked as default. </param>
        /// <returns> A new <see cref="Text.NoMaskPolicyType"/> instance for mocking. </returns>
        public static NoMaskPolicyType NoMaskPolicyType(IEnumerable<PiiCategoriesExclude> entityTypes = default, string policyName = default, bool? isDefaultPolicy = default)
        {
            entityTypes ??= new ChangeTrackingList<PiiCategoriesExclude>();

            return new NoMaskPolicyType(RedactionPolicyKind.NoMask, entityTypes.ToList(), policyName, isDefaultPolicy, additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the policy of redacting PII with the entity type. </summary>
        /// <param name="entityTypes"> (Optional) describes the PII categories to which the redaction policy will be applied. If not specified, the redaction policy will be applied to all PII categories. </param>
        /// <param name="policyName"> (Optional) name of the redaction policy for identification purposes. </param>
        /// <param name="isDefaultPolicy"> (Optional) flag to indicate whether this redaction policy is the default policy to be applied when no specific policy is defined for a PII category. Only one policy can be marked as default. </param>
        /// <returns> A new <see cref="Text.EntityMaskPolicyType"/> instance for mocking. </returns>
        public static EntityMaskPolicyType EntityMaskPolicyType(IEnumerable<PiiCategoriesExclude> entityTypes = default, string policyName = default, bool? isDefaultPolicy = default)
        {
            entityTypes ??= new ChangeTrackingList<PiiCategoriesExclude>();

            return new EntityMaskPolicyType(RedactionPolicyKind.EntityMask, entityTypes.ToList(), policyName, isDefaultPolicy, additionalBinaryDataProperties: null);
        }

        /// <summary> Configuration for confidence score threshold for PII entity recognition. </summary>
        /// <param name="default"> Minimum confidence score threshold for the PII entities to be returned in the response. Entities with a confidence score below this threshold will be filtered out. Value should be between 0.0 and 1.0. </param>
        /// <param name="overrides"> List of confidence score threshold overrides for specific PII categories. </param>
        /// <returns> A new <see cref="Text.ConfidenceScoreThreshold"/> instance for mocking. </returns>
        public static ConfidenceScoreThreshold ConfidenceScoreThreshold(float @default = default, IEnumerable<ConfidenceScoreThresholdOverride> overrides = default)
        {
            overrides ??= new ChangeTrackingList<ConfidenceScoreThresholdOverride>();

            return new ConfidenceScoreThreshold(@default, overrides.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Confidence score threshold override for a specific PII category. </summary>
        /// <param name="entity"> The PII category for which to override the confidence score threshold. </param>
        /// <param name="value"> The confidence score threshold for the specified PII category. </param>
        /// <param name="language"> The 2 letter ISO 639-1 language for which the override applies. If not specified, the override applies to all languages. </param>
        /// <returns> A new <see cref="Text.ConfidenceScoreThresholdOverride"/> instance for mocking. </returns>
        public static ConfidenceScoreThresholdOverride ConfidenceScoreThresholdOverride(PiiCategoriesExclude entity = default, float value = default, string language = default)
        {
            return new ConfidenceScoreThresholdOverride(entity, value, language, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text SentimentAnalysis task input. </summary>
        /// <param name="textInput"> Contains the input documents. </param>
        /// <param name="actionContent"> Sentiment Analysis task parameters. </param>
        /// <returns> A new <see cref="Text.TextSentimentAnalysisInput"/> instance for mocking. </returns>
        public static TextSentimentAnalysisInput TextSentimentAnalysisInput(MultiLanguageTextInput textInput = default, SentimentAnalysisActionContent actionContent = default)
        {
            return new TextSentimentAnalysisInput(AnalyzeTextInputKind.SentimentAnalysis, additionalBinaryDataProperties: null, textInput, actionContent);
        }

        /// <summary> Supported parameters for a Sentiment Analysis task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="opinionMining"> Whether to use opinion mining in the request or not. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. </param>
        /// <returns> A new <see cref="Text.SentimentAnalysisActionContent"/> instance for mocking. </returns>
        public static SentimentAnalysisActionContent SentimentAnalysisActionContent(bool? loggingOptOut = default, string modelVersion = default, bool? opinionMining = default, StringIndexType? stringIndexType = default)
        {
            return new SentimentAnalysisActionContent(loggingOptOut, modelVersion, opinionMining, stringIndexType, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The result object for the analyze task.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.AnalyzeTextEntityLinkingResult"/>, <see cref="Text.AnalyzeTextEntitiesResult"/>, <see cref="Text.AnalyzeTextKeyPhraseResult"/>, <see cref="Text.AnalyzeTextLanguageDetectionResult"/>, <see cref="Text.AnalyzeTextPiiResult"/>, and <see cref="Text.AnalyzeTextSentimentResult"/>.
        /// </summary>
        /// <param name="kind"> The kind of task result. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextResult"/> instance for mocking. </returns>
        public static AnalyzeTextResult AnalyzeTextResult(string kind = default)
        {
            return new UnknownAnalyzeTextResult(new AnalyzeTextResultsKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text Entity linking task result. </summary>
        /// <param name="results"> Entity linking result. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextEntityLinkingResult"/> instance for mocking. </returns>
        public static AnalyzeTextEntityLinkingResult AnalyzeTextEntityLinkingResult(EntityLinkingResult results = default)
        {
            return new AnalyzeTextEntityLinkingResult(AnalyzeTextResultsKind.EntityLinkingResults, additionalBinaryDataProperties: null, results);
        }

        /// <summary> Entity linking result. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.EntityLinkingResult"/> instance for mocking. </returns>
        public static EntityLinkingResult EntityLinkingResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<EntityLinkingActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<EntityLinkingActionResult>();

            return new EntityLinkingResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains details of errors encountered during a job execution. </summary>
        /// <param name="id"> The ID of the input document. </param>
        /// <param name="error"> Error encountered. </param>
        /// <returns> A new <see cref="Text.DocumentError"/> instance for mocking. </returns>
        public static DocumentError DocumentError(string id = default, AnalyzeTextError error = default)
        {
            return new DocumentError(id, error, additionalBinaryDataProperties: null);
        }

        /// <summary> The error response object returned when the service encounters some errors during processing the request. </summary>
        /// <param name="code"> One of a server-defined set of error codes. </param>
        /// <param name="message"> A human-readable representation of the error. </param>
        /// <param name="target"> The target of the error. </param>
        /// <param name="details"> An array of details about specific errors that led to this reported error. </param>
        /// <param name="innererror"> An object containing more specific information than the current object about the error. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextError"/> instance for mocking. </returns>
        public static AnalyzeTextError AnalyzeTextError(AnalyzeTextErrorCode code = default, string message = default, string target = default, IEnumerable<AnalyzeTextError> details = default, InnerErrorModel innererror = default)
        {
            details ??= new ChangeTrackingList<AnalyzeTextError>();

            return new AnalyzeTextError(
                code,
                message,
                target,
                details.ToList(),
                innererror,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object containing more specific information about the error. As per Microsoft One API guidelines - https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses. </summary>
        /// <param name="code"> One of a server-defined set of error codes. </param>
        /// <param name="message"> Error message. </param>
        /// <param name="details"> Error details. </param>
        /// <param name="target"> Error target. </param>
        /// <param name="innererror"> An object containing more specific information than the current object about the error. </param>
        /// <returns> A new <see cref="Text.InnerErrorModel"/> instance for mocking. </returns>
        public static InnerErrorModel InnerErrorModel(InnerErrorCode code = default, string message = default, IDictionary<string, string> details = default, string target = default, InnerErrorModel innererror = default)
        {
            details ??= new ChangeTrackingDictionary<string, string>();

            return new InnerErrorModel(
                code,
                message,
                details,
                target,
                innererror,
                additionalBinaryDataProperties: null);
        }

        /// <summary> if showStats=true was specified in the request this field will contain information about the request payload. </summary>
        /// <param name="documentsCount"> Number of documents submitted in the request. </param>
        /// <param name="validDocumentsCount"> Number of valid documents. This excludes empty, over-size limit or non-supported languages documents. </param>
        /// <param name="erroneousDocumentsCount"> Number of invalid documents. This includes empty, over-size limit or non-supported languages documents. </param>
        /// <param name="transactionsCount"> Number of transactions for the request. </param>
        /// <returns> A new <see cref="Text.RequestStatistics"/> instance for mocking. </returns>
        public static RequestStatistics RequestStatistics(int documentsCount = default, int validDocumentsCount = default, int erroneousDocumentsCount = default, long transactionsCount = default)
        {
            return new RequestStatistics(documentsCount, validDocumentsCount, erroneousDocumentsCount, transactionsCount, additionalBinaryDataProperties: null);
        }

        /// <summary> Entity linking document result with auto language detection. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="entities"> Recognized well known entities in the document. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.EntityLinkingActionResult"/> instance for mocking. </returns>
        public static EntityLinkingActionResult EntityLinkingActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<LinkedEntity> entities = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            entities ??= new ChangeTrackingList<LinkedEntity>();

            return new EntityLinkingActionResult(
                id,
                warnings.ToList(),
                statistics,
                entities.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the warnings object with warnings encountered for the processed document. </summary>
        /// <param name="code"> Warning code. </param>
        /// <param name="message"> Warning message. </param>
        /// <param name="targetRef"> A JSON pointer reference indicating the target object. </param>
        /// <returns> A new <see cref="Text.DocumentWarning"/> instance for mocking. </returns>
        public static DocumentWarning DocumentWarning(WarningCode code = default, string message = default, string targetRef = default)
        {
            return new DocumentWarning(code, message, targetRef, additionalBinaryDataProperties: null);
        }

        /// <summary> if showStats=true was specified in the request this field will contain information about the document payload. </summary>
        /// <param name="charactersCount"> Number of text elements recognized in the document. </param>
        /// <param name="transactionsCount"> Number of transactions for the document. </param>
        /// <returns> A new <see cref="Text.DocumentStatistics"/> instance for mocking. </returns>
        public static DocumentStatistics DocumentStatistics(int charactersCount = default, int transactionsCount = default)
        {
            return new DocumentStatistics(charactersCount, transactionsCount, additionalBinaryDataProperties: null);
        }

        /// <summary> The LinkedEntity object containing the detected entity with the associated sources/links. </summary>
        /// <param name="name"> Entity Linking formal name. </param>
        /// <param name="matches"> List of instances this entity appears in the text. </param>
        /// <param name="language"> Language used in the data source. </param>
        /// <param name="id"> Unique identifier of the recognized entity from the data source. </param>
        /// <param name="url"> URL for the entity's page from the data source. </param>
        /// <param name="dataSource"> Data source used to extract entity linking, such as Wiki/Bing etc. </param>
        /// <param name="bingId"> Bing Entity Search API unique identifier of the recognized entity. </param>
        /// <returns> A new <see cref="Text.LinkedEntity"/> instance for mocking. </returns>
        public static LinkedEntity LinkedEntity(string name = default, IEnumerable<EntityLinkingMatch> matches = default, string language = default, string id = default, string url = default, string dataSource = default, string bingId = default)
        {
            matches ??= new ChangeTrackingList<EntityLinkingMatch>();

            return new LinkedEntity(
                name,
                matches.ToList(),
                language,
                id,
                url,
                dataSource,
                bingId,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The Match object containing the detected entity text with the offset and the length. </summary>
        /// <param name="confidenceScore"> If a well known item is recognized, a decimal number denoting the confidence level between 0 and 1 will be returned. </param>
        /// <param name="text"> Entity text as appears in the request. </param>
        /// <param name="offset"> Start position for the entity match text. </param>
        /// <param name="length"> Length for the entity match text. </param>
        /// <returns> A new <see cref="Text.EntityLinkingMatch"/> instance for mocking. </returns>
        public static EntityLinkingMatch EntityLinkingMatch(double confidenceScore = default, string text = default, int offset = default, int length = default)
        {
            return new EntityLinkingMatch(confidenceScore, text, offset, length, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the details of the detected language for the text. </summary>
        /// <param name="name"> Long name of a detected language (e.g. English, French). </param>
        /// <param name="iso6391Name"> A two letter representation of the detected language according to the ISO 639-1 standard (e.g. en, fr). </param>
        /// <param name="confidenceScore"> A confidence score between 0 and 1. Scores close to 1 indicate 100% certainty that the identified language is true. </param>
        /// <param name="scriptName"> Identifies the script name of the input document according to the ISO 15924 standard. </param>
        /// <param name="scriptIso15924Code"> Identifies the script code of the input document according to the ISO 15924 standard. </param>
        /// <returns> A new <see cref="Text.DetectedLanguage"/> instance for mocking. </returns>
        public static DetectedLanguage DetectedLanguage(string name = default, string iso6391Name = default, double confidenceScore = default, ScriptKind? scriptName = default, ScriptCode? scriptIso15924Code = default)
        {
            return new DetectedLanguage(
                name,
                iso6391Name,
                confidenceScore,
                scriptName,
                scriptIso15924Code,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the entity task. </summary>
        /// <param name="results"> Results for entity recognition. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextEntitiesResult"/> instance for mocking. </returns>
        public static AnalyzeTextEntitiesResult AnalyzeTextEntitiesResult(EntitiesWithMetadataAutoResult results = default)
        {
            return new AnalyzeTextEntitiesResult(AnalyzeTextResultsKind.EntityRecognitionResults, additionalBinaryDataProperties: null, results);
        }

        /// <summary> Contains the entity recognition task result. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.EntitiesWithMetadataAutoResult"/> instance for mocking. </returns>
        public static EntitiesWithMetadataAutoResult EntitiesWithMetadataAutoResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<EntityActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<EntityActionResult>();

            return new EntitiesWithMetadataAutoResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the entity recognition task result for the document with metadata and detected language. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="entities"> Recognized entities in the document. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.EntityActionResult"/> instance for mocking. </returns>
        public static EntityActionResult EntityActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<NamedEntityWithMetadata> entities = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            entities ??= new ChangeTrackingList<NamedEntityWithMetadata>();

            return new EntityActionResult(
                id,
                warnings.ToList(),
                statistics,
                entities.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Entity object with tags and metadata. </summary>
        /// <param name="text"> Entity text as appears in the request. </param>
        /// <param name="category"> Entity type. </param>
        /// <param name="subcategory"> (Optional) Entity sub type. </param>
        /// <param name="offset"> Start position for the entity text. Use of different 'stringIndexType' values can affect the offset returned. </param>
        /// <param name="length"> Length for the entity text. Use of different 'stringIndexType' values can affect the length returned. </param>
        /// <param name="confidenceScore"> Confidence score between 0 and 1 of the extracted entity. </param>
        /// <param name="type"> An entity type is the lowest (or finest) granularity at which the entity has been detected. The type maps to the specific metadata attributes associated with the entity detected. </param>
        /// <param name="tags"> List of entity tags. Tags are to express some similarities/affinity between entities. </param>
        /// <param name="metadata"> The entity metadata object. </param>
        /// <returns> A new <see cref="Text.NamedEntityWithMetadata"/> instance for mocking. </returns>
        public static NamedEntityWithMetadata NamedEntityWithMetadata(string text = default, string category = default, string subcategory = default, int offset = default, int length = default, double confidenceScore = default, string @type = default, IEnumerable<EntityTag> tags = default, BaseMetadata metadata = default)
        {
            tags ??= new ChangeTrackingList<EntityTag>();

            return new NamedEntityWithMetadata(
                text,
                category,
                subcategory,
                offset,
                length,
                confidenceScore,
                @type,
                tags.ToList(),
                metadata,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Entity tag object which contains the name of the tags abd any associated confidence score. Entity Tags are used to express some similarities/affinity between entities. </summary>
        /// <param name="name"> Name of the tag. Entity Tag names will be unique globally. </param>
        /// <param name="confidenceScore"> Detection score between 0 and 1 of the extracted entity. </param>
        /// <returns> A new <see cref="Text.EntityTag"/> instance for mocking. </returns>
        public static EntityTag EntityTag(string name = default, double? confidenceScore = default)
        {
            return new EntityTag(name, confidenceScore, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The abstract base class for entity Metadata.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.AgeMetadata"/>, <see cref="Text.VolumeMetadata"/>, <see cref="Text.SpeedMetadata"/>, <see cref="Text.AreaMetadata"/>, <see cref="Text.LengthMetadata"/>, <see cref="Text.InformationMetadata"/>, <see cref="Text.TemperatureMetadata"/>, <see cref="Text.WeightMetadata"/>, <see cref="Text.CurrencyMetadata"/>, <see cref="Text.AddressMetadata"/>, <see cref="Text.DateMetadata"/>, <see cref="Text.DateTimeMetadata"/>, <see cref="Text.TemporalSetMetadata"/>, <see cref="Text.TimeMetadata"/>, <see cref="Text.NumberMetadata"/>, <see cref="Text.OrdinalMetadata"/>, <see cref="Text.TemporalSpanMetadata"/>, and <see cref="Text.NumericRangeMetadata"/>.
        /// </summary>
        /// <param name="metadataKind"> The entity Metadata object kind. </param>
        /// <returns> A new <see cref="Text.BaseMetadata"/> instance for mocking. </returns>
        public static BaseMetadata BaseMetadata(string metadataKind = default)
        {
            return new UnknownBaseMetadata(new MetadataKind(metadataKind), additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the Age entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for age. </param>
        /// <returns> A new <see cref="Text.AgeMetadata"/> instance for mocking. </returns>
        public static AgeMetadata AgeMetadata(double value = default, AgeUnit unit = default)
        {
            return new AgeMetadata(MetadataKind.AgeMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Volume entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for volume. </param>
        /// <returns> A new <see cref="Text.VolumeMetadata"/> instance for mocking. </returns>
        public static VolumeMetadata VolumeMetadata(double value = default, VolumeUnit unit = default)
        {
            return new VolumeMetadata(MetadataKind.VolumeMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Speed entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for speed. </param>
        /// <returns> A new <see cref="Text.SpeedMetadata"/> instance for mocking. </returns>
        public static SpeedMetadata SpeedMetadata(double value = default, SpeedUnit unit = default)
        {
            return new SpeedMetadata(MetadataKind.SpeedMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Area entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for area. </param>
        /// <returns> A new <see cref="Text.AreaMetadata"/> instance for mocking. </returns>
        public static AreaMetadata AreaMetadata(double value = default, AreaUnit unit = default)
        {
            return new AreaMetadata(MetadataKind.AreaMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Length entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for length. </param>
        /// <returns> A new <see cref="Text.LengthMetadata"/> instance for mocking. </returns>
        public static LengthMetadata LengthMetadata(double value = default, LengthUnit unit = default)
        {
            return new LengthMetadata(MetadataKind.LengthMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Information (data) entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for information. </param>
        /// <returns> A new <see cref="Text.InformationMetadata"/> instance for mocking. </returns>
        public static InformationMetadata InformationMetadata(double value = default, InformationUnit unit = default)
        {
            return new InformationMetadata(MetadataKind.InformationMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Information entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for temperature. </param>
        /// <returns> A new <see cref="Text.TemperatureMetadata"/> instance for mocking. </returns>
        public static TemperatureMetadata TemperatureMetadata(double value = default, TemperatureUnit unit = default)
        {
            return new TemperatureMetadata(MetadataKind.TemperatureMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Weight ) entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Unit of measure for weight. </param>
        /// <returns> A new <see cref="Text.WeightMetadata"/> instance for mocking. </returns>
        public static WeightMetadata WeightMetadata(double value = default, WeightUnit unit = default)
        {
            return new WeightMetadata(MetadataKind.WeightMetadata, additionalBinaryDataProperties: null, value, unit);
        }

        /// <summary> Represents the Currency ) entity Metadata model. </summary>
        /// <param name="value"> The numeric value that the extracted text denotes. </param>
        /// <param name="unit"> Currency unit. </param>
        /// <param name="iso4217"> The alphabetic code based on another ISO standard, ISO 3166, which lists the codes for country names. The first two letters of the ISO 4217 three-letter code are the same as the code for the country name, and, where possible, the third letter corresponds to the first letter of the currency name. </param>
        /// <returns> A new <see cref="Text.CurrencyMetadata"/> instance for mocking. </returns>
        public static CurrencyMetadata CurrencyMetadata(double value = default, string unit = default, string iso4217 = default)
        {
            return new CurrencyMetadata(MetadataKind.CurrencyMetadata, additionalBinaryDataProperties: null, value, unit, iso4217);
        }

        /// <summary> Represents the Address entity Metadata model. </summary>
        /// <param name="formatedAddress"> The fully formatted address string following postal conventions for the address's country/region. </param>
        /// <param name="addressLines"> The full address string as recognized from the input text. </param>
        /// <param name="city"> The city name of the address. </param>
        /// <param name="state"> The state or province name of the address. </param>
        /// <param name="postalCode"> The postal or ZIP code of the address. </param>
        /// <param name="countryOrRegion"> The country or region name of the address. </param>
        /// <returns> A new <see cref="Text.AddressMetadata"/> instance for mocking. </returns>
        public static AddressMetadata AddressMetadata(string formatedAddress = default, IEnumerable<string> addressLines = default, string city = default, string state = default, string postalCode = default, string countryOrRegion = default)
        {
            addressLines ??= new ChangeTrackingList<string>();

            return new AddressMetadata(
                MetadataKind.AddressMetadata,
                additionalBinaryDataProperties: null,
                formatedAddress,
                addressLines.ToList(),
                city,
                state,
                postalCode,
                countryOrRegion);
        }

        /// <summary> A Metadata for date entity instances. </summary>
        /// <param name="dates"> List of date values. </param>
        /// <returns> A new <see cref="Text.DateMetadata"/> instance for mocking. </returns>
        public static DateMetadata DateMetadata(IEnumerable<DateValue> dates = default)
        {
            dates ??= new ChangeTrackingList<DateValue>();

            return new DateMetadata(MetadataKind.DateMetadata, additionalBinaryDataProperties: null, dates.ToList());
        }

        /// <summary> Represents the date value. </summary>
        /// <param name="timex"> An extended ISO 8601 date/time representation as described in (https://github.com/Microsoft/Recognizers-Text/blob/master/Patterns/English/English-DateTime.yaml). </param>
        /// <param name="value"> The actual time that the extracted text denote. </param>
        /// <param name="modifier"> Modifier for datetime to indicate point of reference like before, after etc. </param>
        /// <returns> A new <see cref="Text.DateValue"/> instance for mocking. </returns>
        public static DateValue DateValue(string timex = default, string value = default, TemporalModifier? modifier = default)
        {
            return new DateValue(timex, value, modifier, additionalBinaryDataProperties: null);
        }

        /// <summary> A Metadata for datetime entity instances. </summary>
        /// <param name="dates"> List of date values. </param>
        /// <returns> A new <see cref="Text.DateTimeMetadata"/> instance for mocking. </returns>
        public static DateTimeMetadata DateTimeMetadata(IEnumerable<DateValue> dates = default)
        {
            dates ??= new ChangeTrackingList<DateValue>();

            return new DateTimeMetadata(MetadataKind.DateTimeMetadata, additionalBinaryDataProperties: null, dates.ToList());
        }

        /// <summary> A Metadata for temporal set entity instances. </summary>
        /// <param name="dates"> List of date values. </param>
        /// <returns> A new <see cref="Text.TemporalSetMetadata"/> instance for mocking. </returns>
        public static TemporalSetMetadata TemporalSetMetadata(IEnumerable<DateValue> dates = default)
        {
            dates ??= new ChangeTrackingList<DateValue>();

            return new TemporalSetMetadata(MetadataKind.TemporalSetMetadata, additionalBinaryDataProperties: null, dates.ToList());
        }

        /// <summary> A Metadata for time entity instances. </summary>
        /// <param name="dates"> List of date values. </param>
        /// <returns> A new <see cref="Text.TimeMetadata"/> instance for mocking. </returns>
        public static TimeMetadata TimeMetadata(IEnumerable<DateValue> dates = default)
        {
            dates ??= new ChangeTrackingList<DateValue>();

            return new TimeMetadata(MetadataKind.TimeMetadata, additionalBinaryDataProperties: null, dates.ToList());
        }

        /// <summary> A metadata for numeric entity instances. </summary>
        /// <param name="numberKind"> Kind of the number type. </param>
        /// <param name="value"> A numeric representation of what the extracted text denotes. </param>
        /// <returns> A new <see cref="Text.NumberMetadata"/> instance for mocking. </returns>
        public static NumberMetadata NumberMetadata(NumberKind numberKind = default, double value = default)
        {
            return new NumberMetadata(MetadataKind.NumberMetadata, additionalBinaryDataProperties: null, numberKind, value);
        }

        /// <summary> A metadata for numeric entity instances. </summary>
        /// <param name="offset"> The offset with respect to the reference (e.g., offset = -1 indicates the second to last). </param>
        /// <param name="relativeTo"> The reference point that the ordinal number denotes. </param>
        /// <param name="value"> A simple arithmetic expression that the ordinal denotes. </param>
        /// <returns> A new <see cref="Text.OrdinalMetadata"/> instance for mocking. </returns>
        public static OrdinalMetadata OrdinalMetadata(string offset = default, RelativeTo relativeTo = default, string value = default)
        {
            return new OrdinalMetadata(MetadataKind.OrdinalMetadata, additionalBinaryDataProperties: null, offset, relativeTo, value);
        }

        /// <summary> represents the Metadata of a date and/or time span. </summary>
        /// <param name="spanValues"> List of temporal spans detected. </param>
        /// <returns> A new <see cref="Text.TemporalSpanMetadata"/> instance for mocking. </returns>
        public static TemporalSpanMetadata TemporalSpanMetadata(IEnumerable<TemporalSpanValues> spanValues = default)
        {
            spanValues ??= new ChangeTrackingList<TemporalSpanValues>();

            return new TemporalSpanMetadata(MetadataKind.TemporalSpanMetadata, additionalBinaryDataProperties: null, spanValues.ToList());
        }

        /// <summary> Temporal span object. </summary>
        /// <param name="begin"> Start value for the span. </param>
        /// <param name="end"> End value for the span. </param>
        /// <param name="duration"> An optional duration value formatted based on the ISO 8601 (https://en.wikipedia.org/wiki/ISO_8601#Durations). </param>
        /// <param name="modifier"> Modifier for datetime to indicate point of reference like before, after etc. </param>
        /// <param name="timex"> An optional triplet containing the beginning, the end, and the duration all stated as ISO 8601 formatted strings. </param>
        /// <returns> A new <see cref="Text.TemporalSpanValues"/> instance for mocking. </returns>
        public static TemporalSpanValues TemporalSpanValues(string begin = default, string end = default, string duration = default, TemporalModifier? modifier = default, string timex = default)
        {
            return new TemporalSpanValues(
                begin,
                end,
                duration,
                modifier,
                timex,
                additionalBinaryDataProperties: null);
        }

        /// <summary> represents the Metadata of numeric intervals. </summary>
        /// <param name="rangeKind"> Kind of numeric ranges supported - like Number, Speed, etc. </param>
        /// <param name="minimum"> The beginning value of  the interval. </param>
        /// <param name="maximum"> The ending value of the interval. </param>
        /// <param name="rangeInclusivity"> The inclusiveness of this range. </param>
        /// <returns> A new <see cref="Text.NumericRangeMetadata"/> instance for mocking. </returns>
        public static NumericRangeMetadata NumericRangeMetadata(RangeKind rangeKind = default, double minimum = default, double maximum = default, RangeInclusivity? rangeInclusivity = default)
        {
            return new NumericRangeMetadata(
                MetadataKind.NumericRangeMetadata,
                additionalBinaryDataProperties: null,
                rangeKind,
                minimum,
                maximum,
                rangeInclusivity);
        }

        /// <summary> Contains the analyze text KeyPhraseExtraction task result. </summary>
        /// <param name="results"> The list of Key phrase extraction results. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextKeyPhraseResult"/> instance for mocking. </returns>
        public static AnalyzeTextKeyPhraseResult AnalyzeTextKeyPhraseResult(KeyPhraseResult results = default)
        {
            return new AnalyzeTextKeyPhraseResult(AnalyzeTextResultsKind.KeyPhraseExtractionResults, additionalBinaryDataProperties: null, results);
        }

        /// <summary> Contains the KeyPhraseResult. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.KeyPhraseResult"/> instance for mocking. </returns>
        public static KeyPhraseResult KeyPhraseResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<KeyPhrasesActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<KeyPhrasesActionResult>();

            return new KeyPhraseResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A ranked list of sentences representing the extracted summary. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="keyPhrases"> A list of representative words or phrases. The number of key phrases returned is proportional to the number of words in the input document. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.KeyPhrasesActionResult"/> instance for mocking. </returns>
        public static KeyPhrasesActionResult KeyPhrasesActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<string> keyPhrases = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            keyPhrases ??= new ChangeTrackingList<string>();

            return new KeyPhrasesActionResult(
                id,
                warnings.ToList(),
                statistics,
                keyPhrases.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the language detection task result for the request. </summary>
        /// <param name="results"> Contains the language detection results. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextLanguageDetectionResult"/> instance for mocking. </returns>
        public static AnalyzeTextLanguageDetectionResult AnalyzeTextLanguageDetectionResult(LanguageDetectionResult results = default)
        {
            return new AnalyzeTextLanguageDetectionResult(AnalyzeTextResultsKind.LanguageDetectionResults, additionalBinaryDataProperties: null, results);
        }

        /// <summary> Contains the language detection result for the request. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Enumeration of language detection results for each input document. </param>
        /// <returns> A new <see cref="Text.LanguageDetectionResult"/> instance for mocking. </returns>
        public static LanguageDetectionResult LanguageDetectionResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<LanguageDetectionDocumentResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<LanguageDetectionDocumentResult>();

            return new LanguageDetectionResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the language detection for a document. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="detectedLanguage"> Detected Language. </param>
        /// <returns> A new <see cref="Text.LanguageDetectionDocumentResult"/> instance for mocking. </returns>
        public static LanguageDetectionDocumentResult LanguageDetectionDocumentResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();

            return new LanguageDetectionDocumentResult(id, warnings.ToList(), statistics, detectedLanguage, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text PIIEntityRecognition LRO task. </summary>
        /// <param name="results"> The list of pii results. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextPiiResult"/> instance for mocking. </returns>
        public static AnalyzeTextPiiResult AnalyzeTextPiiResult(PiiResult results = default)
        {
            return new AnalyzeTextPiiResult(AnalyzeTextResultsKind.PiiEntityRecognitionResults, additionalBinaryDataProperties: null, results);
        }

        /// <summary> Contains the PiiResult. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.PiiResult"/> instance for mocking. </returns>
        public static PiiResult PiiResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<PiiResultWithDetectedLanguage> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<PiiResultWithDetectedLanguage>();

            return new PiiResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the PII results with detected language. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="redactedText"> Returns redacted text. </param>
        /// <param name="entities"> Recognized entities in the document. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.PiiResultWithDetectedLanguage"/> instance for mocking. </returns>
        public static PiiResultWithDetectedLanguage PiiResultWithDetectedLanguage(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, string redactedText = default, IEnumerable<PiiEntity> entities = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            entities ??= new ChangeTrackingList<PiiEntity>();

            return new PiiResultWithDetectedLanguage(
                id,
                warnings.ToList(),
                statistics,
                redactedText,
                entities.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Entity object with tags. </summary>
        /// <param name="text"> Entity text as appears in the request. </param>
        /// <param name="category"> Entity type. </param>
        /// <param name="subcategory"> (Optional) Entity sub type. </param>
        /// <param name="offset"> Start position for the entity text. Use of different 'stringIndexType' values can affect the offset returned. </param>
        /// <param name="length"> Length for the entity text. Use of different 'stringIndexType' values can affect the length returned. </param>
        /// <param name="confidenceScore"> Confidence score between 0 and 1 of the extracted entity. </param>
        /// <param name="type"> An entity type is the lowest (or finest) granularity at which the entity has been detected. The type maps to the specific metadata attributes associated with the entity detected. </param>
        /// <param name="tags"> List of entity tags. Tags are to express some similarities/affinity between entities. </param>
        /// <param name="mask"> Optional field which will be returned only when using the redaction policy kind MaskWithEntityType.  This field will contain the exact mask text used to mask the PII entity in the original text. </param>
        /// <param name="maskOffset"> Start position of masked text in the redacted text when using the redaction policy kind MaskWithEntityType. </param>
        /// <param name="maskLength"> The length of the masked text. Will be present when using the redaction policy kind MaskWithEntityType. </param>
        /// <returns> A new <see cref="Text.PiiEntity"/> instance for mocking. </returns>
        public static PiiEntity PiiEntity(string text = default, string category = default, string subcategory = default, int offset = default, int length = default, double confidenceScore = default, string @type = default, IEnumerable<EntityTag> tags = default, string mask = default, int? maskOffset = default, int? maskLength = default)
        {
            tags ??= new ChangeTrackingList<EntityTag>();

            return new PiiEntity(
                text,
                category,
                subcategory,
                offset,
                length,
                confidenceScore,
                @type,
                tags.ToList(),
                mask,
                maskOffset,
                maskLength,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text SentimentAnalysis LRO task result. </summary>
        /// <param name="results"> The sentiment analysis results. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextSentimentResult"/> instance for mocking. </returns>
        public static AnalyzeTextSentimentResult AnalyzeTextSentimentResult(SentimentResult results = default)
        {
            return new AnalyzeTextSentimentResult(AnalyzeTextResultsKind.SentimentAnalysisResults, additionalBinaryDataProperties: null, results);
        }

        /// <summary> Sentiment analysis results for the input documents. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> The sentiment analysis results for each document in the input. </param>
        /// <returns> A new <see cref="Text.SentimentResult"/> instance for mocking. </returns>
        public static SentimentResult SentimentResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<SentimentActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<SentimentActionResult>();

            return new SentimentResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Sentiment analysis per document. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="sentiment"> Predicted sentiment for document (Negative, Neutral, Positive, or Mixed). </param>
        /// <param name="confidenceScores"> The sentiment confidence score between 0 and 1 for the sentence for all classes. </param>
        /// <param name="sentences"> The document's sentences sentiment. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.SentimentActionResult"/> instance for mocking. </returns>
        public static SentimentActionResult SentimentActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, DocumentSentiment sentiment = default, SentimentConfidenceScores confidenceScores = default, IEnumerable<SentenceSentiment> sentences = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            sentences ??= new ChangeTrackingList<SentenceSentiment>();

            return new SentimentActionResult(
                id,
                warnings.ToList(),
                statistics,
                sentiment,
                confidenceScores,
                sentences.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the confidence scores between 0 and 1 across all sentiment classes: positive, neutral, negative. </summary>
        /// <param name="positive"> Confidence score for positive sentiment. </param>
        /// <param name="neutral"> Confidence score for neutral sentiment. </param>
        /// <param name="negative"> Confidence score for negative sentiment. </param>
        /// <returns> A new <see cref="Text.SentimentConfidenceScores"/> instance for mocking. </returns>
        public static SentimentConfidenceScores SentimentConfidenceScores(double positive = default, double neutral = default, double negative = default)
        {
            return new SentimentConfidenceScores(positive, neutral, negative, additionalBinaryDataProperties: null);
        }

        /// <summary> A document's sentence sentiment. </summary>
        /// <param name="text"> The sentence text. </param>
        /// <param name="sentiment"> The predicted Sentiment for the sentence. </param>
        /// <param name="confidenceScores"> The sentiment confidence score between 0 and 1 for the sentence for all classes. </param>
        /// <param name="offset"> The target offset from the start of the sentence. </param>
        /// <param name="length"> The length of the target. </param>
        /// <param name="targets"> The array of sentence targets for the sentence. </param>
        /// <param name="assessments"> The array of assessments for the sentence. </param>
        /// <returns> A new <see cref="Text.SentenceSentiment"/> instance for mocking. </returns>
        public static SentenceSentiment SentenceSentiment(string text = default, SentenceSentimentValue sentiment = default, SentimentConfidenceScores confidenceScores = default, int offset = default, int length = default, IEnumerable<SentenceTarget> targets = default, IEnumerable<SentenceAssessment> assessments = default)
        {
            targets ??= new ChangeTrackingList<SentenceTarget>();
            assessments ??= new ChangeTrackingList<SentenceAssessment>();

            return new SentenceSentiment(
                text,
                sentiment,
                confidenceScores,
                offset,
                length,
                targets.ToList(),
                assessments.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Represents a sentence target and the assessments or target objects related to it. </summary>
        /// <param name="sentiment"> The sentiment of the sentence. </param>
        /// <param name="confidenceScores"> Represents the confidence scores across all sentiment classes: positive and negative. </param>
        /// <param name="offset"> The target offset from the start of the sentence. </param>
        /// <param name="length"> The length of the target. </param>
        /// <param name="text"> The target text detected. </param>
        /// <param name="relations"> The array of either assessment or target objects which is related to the target. </param>
        /// <returns> A new <see cref="Text.SentenceTarget"/> instance for mocking. </returns>
        public static SentenceTarget SentenceTarget(TokenSentiment sentiment = default, TargetConfidenceScoreLabel confidenceScores = default, int offset = default, int length = default, string text = default, IEnumerable<TargetRelation> relations = default)
        {
            relations ??= new ChangeTrackingList<TargetRelation>();

            return new SentenceTarget(
                sentiment,
                confidenceScores,
                offset,
                length,
                text,
                relations.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the confidence scores across all sentiment classes: positive and negative. </summary>
        /// <param name="positive"> Confidence score for positive sentiment. </param>
        /// <param name="negative"> Confidence score for negative sentiment. </param>
        /// <returns> A new <see cref="Text.TargetConfidenceScoreLabel"/> instance for mocking. </returns>
        public static TargetConfidenceScoreLabel TargetConfidenceScoreLabel(double positive = default, double negative = default)
        {
            return new TargetConfidenceScoreLabel(positive, negative, additionalBinaryDataProperties: null);
        }

        /// <summary> Represents the relation between assessments and/or targets. </summary>
        /// <param name="ref"> The JSON pointer indicating the linked object. </param>
        /// <param name="relationType"> The type related to the target. </param>
        /// <returns> A new <see cref="Text.TargetRelation"/> instance for mocking. </returns>
        public static TargetRelation TargetRelation(string @ref = default, TargetRelationType relationType = default)
        {
            return new TargetRelation(@ref, relationType, additionalBinaryDataProperties: null);
        }

        /// <summary> Represents a sentence assessment and the assessments or target objects related to it. </summary>
        /// <param name="sentiment"> The sentiment of the sentence. </param>
        /// <param name="confidenceScores"> Represents the confidence scores across all sentiment classes: positive and negative. </param>
        /// <param name="offset"> The target offset from the start of the sentence. </param>
        /// <param name="length"> The length of the target. </param>
        /// <param name="text"> The target text detected. </param>
        /// <param name="isNegated"> The indicator representing if the assessment is negated. </param>
        /// <returns> A new <see cref="Text.SentenceAssessment"/> instance for mocking. </returns>
        public static SentenceAssessment SentenceAssessment(TokenSentiment sentiment = default, TargetConfidenceScoreLabel confidenceScores = default, int offset = default, int length = default, string text = default, bool isNegated = default)
        {
            return new SentenceAssessment(
                sentiment,
                confidenceScores,
                offset,
                length,
                text,
                isNegated,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The object containing the analyze job LRO job state. </summary>
        /// <param name="displayName"> display name. </param>
        /// <param name="createdAt"> Date and time job created. </param>
        /// <param name="expiresOn"> Date and time job expires. </param>
        /// <param name="jobId"> job ID. </param>
        /// <param name="lastUpdatedAt"> last updated date and time. </param>
        /// <param name="status"> status. </param>
        /// <param name="errors"> errors. </param>
        /// <param name="nextLink"> next link. </param>
        /// <param name="tasks"> List of tasks. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextJobState"/> instance for mocking. </returns>
        public static AnalyzeTextJobState AnalyzeTextJobState(string displayName = default, DateTimeOffset createdAt = default, DateTimeOffset? expiresOn = default, Guid jobId = default, DateTimeOffset lastUpdatedAt = default, TextActionState status = default, IEnumerable<AnalyzeTextError> errors = default, string nextLink = default, TextActions tasks = default, RequestStatistics statistics = default)
        {
            errors ??= new ChangeTrackingList<AnalyzeTextError>();

            return new AnalyzeTextJobState(
                displayName,
                createdAt,
                expiresOn,
                jobId,
                lastUpdatedAt,
                status,
                errors.ToList(),
                nextLink,
                tasks,
                statistics,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Container for the tasks status for the LRO job. </summary>
        /// <param name="completed"> Count of completed tasks. </param>
        /// <param name="failed"> Count of failed tasks. </param>
        /// <param name="inProgress"> Count of inprogress tasks. </param>
        /// <param name="total"> Count of total tasks. </param>
        /// <param name="items"> Enumerable of Analyze text job results. </param>
        /// <returns> A new <see cref="Text.TextActions"/> instance for mocking. </returns>
        public static TextActions TextActions(int completed = default, int failed = default, int inProgress = default, int total = default, IEnumerable<AnalyzeTextLROResult> items = default)
        {
            items ??= new ChangeTrackingList<AnalyzeTextLROResult>();

            return new TextActions(
                completed,
                failed,
                inProgress,
                total,
                items.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Contains the AnalyzeText long running operation result object.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.CustomEntityRecognitionOperationResult"/>, <see cref="Text.CustomSingleLabelClassificationOperationResult"/>, <see cref="Text.CustomMultiLabelClassificationOperationResult"/>, <see cref="Text.EntityLinkingOperationResult"/>, <see cref="Text.EntityRecognitionOperationResult"/>, <see cref="Text.HealthcareLROResult"/>, <see cref="Text.KeyPhraseExtractionOperationResult"/>, <see cref="Text.PiiEntityRecognitionOperationResult"/>, <see cref="Text.SentimentLROResult"/>, <see cref="Text.ExtractiveSummarizationOperationResult"/>, and <see cref="Text.AbstractiveSummarizationOperationResult"/>.
        /// </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="kind"> Kind of the task. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextLROResult"/> instance for mocking. </returns>
        public static AnalyzeTextLROResult AnalyzeTextLROResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, string kind = default)
        {
            return new UnknownAnalyzeTextLROResult(lastUpdateDateTime, status, taskName, new AnalyzeTextOperationResultsKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the custom entity recognition job result. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> List of results. </param>
        /// <returns> A new <see cref="Text.CustomEntityRecognitionOperationResult"/> instance for mocking. </returns>
        public static CustomEntityRecognitionOperationResult CustomEntityRecognitionOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, CustomEntitiesResult results = default)
        {
            return new CustomEntityRecognitionOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.CustomEntityRecognitionOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the list of detected custom entities result for the documents. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="projectName"> This field indicates the project name for the model. </param>
        /// <param name="deploymentName"> This field indicates the deployment name for the model. </param>
        /// <param name="documents"> Enumeration of the document results. </param>
        /// <returns> A new <see cref="Text.CustomEntitiesResult"/> instance for mocking. </returns>
        public static CustomEntitiesResult CustomEntitiesResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string projectName = default, string deploymentName = default, IEnumerable<CustomEntityActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<CustomEntityActionResult>();

            return new CustomEntitiesResult(
                errors.ToList(),
                statistics,
                projectName,
                deploymentName,
                documents.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the entity recognition task result for the document with detected language. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="entities"> Recognized entities in the document. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.CustomEntityActionResult"/> instance for mocking. </returns>
        public static CustomEntityActionResult CustomEntityActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<NamedEntity> entities = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            entities ??= new ChangeTrackingList<NamedEntity>();

            return new CustomEntityActionResult(
                id,
                warnings.ToList(),
                statistics,
                entities.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Defines the detected entity object containing the entity category and entity text detected, etc. </summary>
        /// <param name="text"> Entity text as appears in the request. </param>
        /// <param name="category"> Entity type. </param>
        /// <param name="subcategory"> (Optional) Entity sub type. </param>
        /// <param name="offset"> Start position for the entity text. Use of different 'stringIndexType' values can affect the offset returned. </param>
        /// <param name="length"> Length for the entity text. Use of different 'stringIndexType' values can affect the length returned. </param>
        /// <param name="confidenceScore"> Confidence score between 0 and 1 of the extracted entity. </param>
        /// <returns> A new <see cref="Text.NamedEntity"/> instance for mocking. </returns>
        public static NamedEntity NamedEntity(string text = default, string category = default, string subcategory = default, int offset = default, int length = default, double confidenceScore = default)
        {
            return new NamedEntity(
                text,
                category,
                subcategory,
                offset,
                length,
                confidenceScore,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the custom single label classification job result. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> List of results. </param>
        /// <returns> A new <see cref="Text.CustomSingleLabelClassificationOperationResult"/> instance for mocking. </returns>
        public static CustomSingleLabelClassificationOperationResult CustomSingleLabelClassificationOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, CustomLabelClassificationResult results = default)
        {
            return new CustomSingleLabelClassificationOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.CustomSingleLabelClassificationOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the custom label classification results. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="projectName"> This field indicates the project name for the model. </param>
        /// <param name="deploymentName"> This field indicates the deployment name for the model. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.CustomLabelClassificationResult"/> instance for mocking. </returns>
        public static CustomLabelClassificationResult CustomLabelClassificationResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string projectName = default, string deploymentName = default, IEnumerable<ClassificationActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<ClassificationActionResult>();

            return new CustomLabelClassificationResult(
                errors.ToList(),
                statistics,
                projectName,
                deploymentName,
                documents.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the classification doc result for the task with detected language. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="class"> Contains the classification doc results for all docs. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.ClassificationActionResult"/> instance for mocking. </returns>
        public static ClassificationActionResult ClassificationActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<ClassificationResult> @class = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            @class ??= new ChangeTrackingList<ClassificationResult>();

            return new ClassificationActionResult(
                id,
                warnings.ToList(),
                statistics,
                @class.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the classification result. </summary>
        /// <param name="category"> Classification type. </param>
        /// <param name="confidenceScore"> Confidence score between 0 and 1 of the recognized class. </param>
        /// <returns> A new <see cref="Text.ClassificationResult"/> instance for mocking. </returns>
        public static ClassificationResult ClassificationResult(string category = default, double confidenceScore = default)
        {
            return new ClassificationResult(category, confidenceScore, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the custom multi label classification job result. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> List of results. </param>
        /// <returns> A new <see cref="Text.CustomMultiLabelClassificationOperationResult"/> instance for mocking. </returns>
        public static CustomMultiLabelClassificationOperationResult CustomMultiLabelClassificationOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, CustomLabelClassificationResult results = default)
        {
            return new CustomMultiLabelClassificationOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.CustomMultiLabelClassificationOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the analyze text Entity linking task LRO result. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> Entity linking result. </param>
        /// <returns> A new <see cref="Text.EntityLinkingOperationResult"/> instance for mocking. </returns>
        public static EntityLinkingOperationResult EntityLinkingOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, EntityLinkingResult results = default)
        {
            return new EntityLinkingOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.EntityLinkingOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the entity recognition job task result. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> Results for the task. </param>
        /// <returns> A new <see cref="Text.EntityRecognitionOperationResult"/> instance for mocking. </returns>
        public static EntityRecognitionOperationResult EntityRecognitionOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, EntitiesResult results = default)
        {
            return new EntityRecognitionOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.EntityRecognitionOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the entity recognition task result. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.EntitiesResult"/> instance for mocking. </returns>
        public static EntitiesResult EntitiesResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<EntityActionResultWithMetadata> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<EntityActionResultWithMetadata>();

            return new EntitiesResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Entity documents result with metadata. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="entities"> Recognized entities in the document. </param>
        /// <returns> A new <see cref="Text.EntityActionResultWithMetadata"/> instance for mocking. </returns>
        public static EntityActionResultWithMetadata EntityActionResultWithMetadata(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<NamedEntityWithMetadata> entities = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            entities ??= new ChangeTrackingList<NamedEntityWithMetadata>();

            return new EntityActionResultWithMetadata(id, warnings.ToList(), statistics, entities.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Healthcare Analyze Text long tunning operation result object. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> Results of the task. </param>
        /// <returns> A new <see cref="Text.HealthcareLROResult"/> instance for mocking. </returns>
        public static HealthcareLROResult HealthcareLROResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, HealthcareResult results = default)
        {
            return new HealthcareLROResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.HealthcareOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Result object for the processed Healthcare task. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> List of result objects for the processed Healthcare documents. </param>
        /// <returns> A new <see cref="Text.HealthcareResult"/> instance for mocking. </returns>
        public static HealthcareResult HealthcareResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<HealthcareActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<HealthcareActionResult>();

            return new HealthcareResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Result object for the processed Healthcare document with detected language. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="entities"> Healthcare entities. </param>
        /// <param name="relations"> Healthcare entity relations. </param>
        /// <param name="fhirBundle"> JSON bundle containing a FHIR compatible object for consumption in other Healthcare tools. For additional information see https://www.hl7.org/fhir/overview.html. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.HealthcareActionResult"/> instance for mocking. </returns>
        public static HealthcareActionResult HealthcareActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<HealthcareEntity> entities = default, IEnumerable<HealthcareRelation> relations = default, FhirBundle fhirBundle = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            entities ??= new ChangeTrackingList<HealthcareEntity>();
            relations ??= new ChangeTrackingList<HealthcareRelation>();

            return new HealthcareActionResult(
                id,
                warnings.ToList(),
                statistics,
                entities.ToList(),
                relations.ToList(),
                fhirBundle,
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Healthcare entity extracted from the document. </summary>
        /// <param name="text"> Entity text as appears in the request. </param>
        /// <param name="category"> Healthcare Entity Category. </param>
        /// <param name="subcategory"> (Optional) Entity sub type. </param>
        /// <param name="offset"> Start position for the entity text. Use of different 'stringIndexType' values can affect the offset returned. </param>
        /// <param name="length"> Length for the entity text. Use of different 'stringIndexType' values can affect the length returned. </param>
        /// <param name="confidenceScore"> Confidence score between 0 and 1 of the extracted entity. </param>
        /// <param name="assertion"> Assertion of the entity. </param>
        /// <param name="name"> Preferred name for the entity. Example: 'histologically' would have a 'name' of 'histologic'. </param>
        /// <param name="links"> Entity references in known data sources. </param>
        /// <returns> A new <see cref="Text.HealthcareEntity"/> instance for mocking. </returns>
        public static HealthcareEntity HealthcareEntity(string text = default, HealthcareEntityCategory category = default, string subcategory = default, int offset = default, int length = default, double confidenceScore = default, HealthcareAssertion assertion = default, string name = default, IEnumerable<HealthcareEntityLink> links = default)
        {
            links ??= new ChangeTrackingList<HealthcareEntityLink>();

            return new HealthcareEntity(
                text,
                category,
                subcategory,
                offset,
                length,
                confidenceScore,
                assertion,
                name,
                links.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Assertion of the entity. </summary>
        /// <param name="conditionality"> Describes any conditionality on the entity. </param>
        /// <param name="certainty"> Describes the entities certainty and polarity. </param>
        /// <param name="association"> Describes if the entity is the subject of the text or if it describes someone else. </param>
        /// <param name="temporality"> Describes temporal information regarding the entity. </param>
        /// <returns> A new <see cref="Text.HealthcareAssertion"/> instance for mocking. </returns>
        public static HealthcareAssertion HealthcareAssertion(HealthcareAssertionConditionality? conditionality = default, HealthcareAssertionCertainty? certainty = default, HealthcareAssertionAssociation? association = default, HealthcareAssertionTemporality? temporality = default)
        {
            return new HealthcareAssertion(conditionality, certainty, association, temporality, additionalBinaryDataProperties: null);
        }

        /// <summary> Reference to an entity in known data sources. </summary>
        /// <param name="dataSource"> Entity Catalog. Examples include: UMLS, CHV, MSH, etc. </param>
        /// <param name="id"> Entity id in the given source catalog. </param>
        /// <returns> A new <see cref="Text.HealthcareEntityLink"/> instance for mocking. </returns>
        public static HealthcareEntityLink HealthcareEntityLink(string dataSource = default, string id = default)
        {
            return new HealthcareEntityLink(dataSource, id, additionalBinaryDataProperties: null);
        }

        /// <summary> Every relation is an entity graph of a certain relationType, where all entities are connected and have specific roles within the relation context. </summary>
        /// <param name="relationType"> Type of relation. Examples include: `DosageOfMedication` or 'FrequencyOfMedication', etc. </param>
        /// <param name="entities"> The entities in the relation. </param>
        /// <param name="confidenceScore"> Confidence score between 0 and 1 of the extracted relation. </param>
        /// <returns> A new <see cref="Text.HealthcareRelation"/> instance for mocking. </returns>
        public static HealthcareRelation HealthcareRelation(RelationType relationType = default, IEnumerable<HealthcareRelationEntity> entities = default, double? confidenceScore = default)
        {
            entities ??= new ChangeTrackingList<HealthcareRelationEntity>();

            return new HealthcareRelation(relationType, entities.ToList(), confidenceScore, additionalBinaryDataProperties: null);
        }

        /// <summary> Entity in the relation. </summary>
        /// <param name="ref"> Reference link object, using a JSON pointer RFC 6901 (URI Fragment Identifier Representation), pointing to the entity . </param>
        /// <param name="role"> Role of entity in the relationship. For example: 'CD20-positive diffuse large B-cell lymphoma' has the following entities with their roles in parenthesis:  CD20 (GeneOrProtein), Positive (Expression), diffuse large B-cell lymphoma (Diagnosis). </param>
        /// <returns> A new <see cref="Text.HealthcareRelationEntity"/> instance for mocking. </returns>
        public static HealthcareRelationEntity HealthcareRelationEntity(string @ref = default, string role = default)
        {
            return new HealthcareRelationEntity(@ref, role, additionalBinaryDataProperties: null);
        }

        /// <summary> JSON bundle containing a FHIR compatible object for consumption in other Healthcare tools. For additional information see https://www.hl7.org/fhir/overview.html. </summary>
        /// <param name="additionalProperties"></param>
        /// <returns> A new <see cref="Text.FhirBundle"/> instance for mocking. </returns>
        public static FhirBundle FhirBundle(IReadOnlyDictionary<string, BinaryData> additionalProperties = default)
        {
            additionalProperties ??= new ChangeTrackingDictionary<string, BinaryData>();

            return new FhirBundle(additionalProperties);
        }

        /// <summary> Contains the analyze text KeyPhraseExtraction LRO task. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> The list of Key phrase extraction results. </param>
        /// <returns> A new <see cref="Text.KeyPhraseExtractionOperationResult"/> instance for mocking. </returns>
        public static KeyPhraseExtractionOperationResult KeyPhraseExtractionOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, KeyPhraseResult results = default)
        {
            return new KeyPhraseExtractionOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.KeyPhraseExtractionOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the PII LRO results. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> The list of pii results. </param>
        /// <returns> A new <see cref="Text.PiiEntityRecognitionOperationResult"/> instance for mocking. </returns>
        public static PiiEntityRecognitionOperationResult PiiEntityRecognitionOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, PiiResult results = default)
        {
            return new PiiEntityRecognitionOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.PiiEntityRecognitionOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> Contains the Sentiment Analysis LRO results. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> The sentiment analysis results. </param>
        /// <returns> A new <see cref="Text.SentimentLROResult"/> instance for mocking. </returns>
        public static SentimentLROResult SentimentLROResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, SentimentResult results = default)
        {
            return new SentimentLROResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.SentimentAnalysisOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> An object representing the results for an Extractive Summarization task. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> Results of the task. </param>
        /// <returns> A new <see cref="Text.ExtractiveSummarizationOperationResult"/> instance for mocking. </returns>
        public static ExtractiveSummarizationOperationResult ExtractiveSummarizationOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, ExtractiveSummarizationResult results = default)
        {
            return new ExtractiveSummarizationOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.ExtractiveSummarizationOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> An object representing the pre-built Extractive Summarization results of each document. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.ExtractiveSummarizationResult"/> instance for mocking. </returns>
        public static ExtractiveSummarizationResult ExtractiveSummarizationResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<ExtractedSummaryActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<ExtractedSummaryActionResult>();

            return new ExtractiveSummarizationResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A ranked list of sentences representing the extracted summary. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="sentences"> Specifies the the extracted sentences from the input document. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.ExtractedSummaryActionResult"/> instance for mocking. </returns>
        public static ExtractedSummaryActionResult ExtractedSummaryActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<ExtractedSummarySentence> sentences = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            sentences ??= new ChangeTrackingList<ExtractedSummarySentence>();

            return new ExtractedSummaryActionResult(
                id,
                warnings.ToList(),
                statistics,
                sentences.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Represents an extracted sentences from the input document. </summary>
        /// <param name="text"> The extracted sentence text. </param>
        /// <param name="rankScore"> A double value representing the relevance of the sentence within the summary. Higher values indicate higher importance. </param>
        /// <param name="offset"> The sentence offset from the start of the document, based on the value of the parameter StringIndexType. </param>
        /// <param name="length"> The length of the sentence. </param>
        /// <returns> A new <see cref="Text.ExtractedSummarySentence"/> instance for mocking. </returns>
        public static ExtractedSummarySentence ExtractedSummarySentence(string text = default, double rankScore = default, int offset = default, int length = default)
        {
            return new ExtractedSummarySentence(text, rankScore, offset, length, additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the results for an Abstractive Summarization task. </summary>
        /// <param name="lastUpdateDateTime"> The last updated time in UTC for the task. </param>
        /// <param name="status"> The status of the task at the mentioned last update time. </param>
        /// <param name="taskName"> task name. </param>
        /// <param name="results"> Results of the task. </param>
        /// <returns> A new <see cref="Text.AbstractiveSummarizationOperationResult"/> instance for mocking. </returns>
        public static AbstractiveSummarizationOperationResult AbstractiveSummarizationOperationResult(DateTimeOffset lastUpdateDateTime = default, TextActionState status = default, string taskName = default, AbstractiveSummarizationResult results = default)
        {
            return new AbstractiveSummarizationOperationResult(
                lastUpdateDateTime,
                status,
                taskName,
                AnalyzeTextOperationResultsKind.AbstractiveSummarizationOperationResults,
                additionalBinaryDataProperties: null,
                results);
        }

        /// <summary> An object representing the pre-built Abstractive Summarization results of each document. </summary>
        /// <param name="errors"> Errors by document id. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the request payload. </param>
        /// <param name="modelVersion"> This field indicates which model is used for scoring. </param>
        /// <param name="documents"> Response by document. </param>
        /// <returns> A new <see cref="Text.AbstractiveSummarizationResult"/> instance for mocking. </returns>
        public static AbstractiveSummarizationResult AbstractiveSummarizationResult(IEnumerable<DocumentError> errors = default, RequestStatistics statistics = default, string modelVersion = default, IEnumerable<AbstractiveSummaryActionResult> documents = default)
        {
            errors ??= new ChangeTrackingList<DocumentError>();
            documents ??= new ChangeTrackingList<AbstractiveSummaryActionResult>();

            return new AbstractiveSummarizationResult(errors.ToList(), statistics, modelVersion, documents.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the Abstractive Summarization result of a single document with detected language. </summary>
        /// <param name="id"> Unique, non-empty document identifier. </param>
        /// <param name="warnings"> Warnings encountered while processing document. </param>
        /// <param name="statistics"> if showStats=true was specified in the request this field will contain information about the document payload. </param>
        /// <param name="summaries"> A list of abstractive summaries. </param>
        /// <param name="detectedLanguage"> If 'language' is set to 'auto' for the document in the request this field will contain a 2 letter ISO 639-1 representation of the language detected for this document. </param>
        /// <returns> A new <see cref="Text.AbstractiveSummaryActionResult"/> instance for mocking. </returns>
        public static AbstractiveSummaryActionResult AbstractiveSummaryActionResult(string id = default, IEnumerable<DocumentWarning> warnings = default, DocumentStatistics statistics = default, IEnumerable<AbstractiveSummary> summaries = default, DetectedLanguage detectedLanguage = default)
        {
            warnings ??= new ChangeTrackingList<DocumentWarning>();
            summaries ??= new ChangeTrackingList<AbstractiveSummary>();

            return new AbstractiveSummaryActionResult(
                id,
                warnings.ToList(),
                statistics,
                summaries.ToList(),
                detectedLanguage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing a single summary with context for given document. </summary>
        /// <param name="text"> The text of the summary. </param>
        /// <param name="contexts"> The context list of the summary. </param>
        /// <returns> A new <see cref="Text.AbstractiveSummary"/> instance for mocking. </returns>
        public static AbstractiveSummary AbstractiveSummary(string text = default, IEnumerable<SummaryContext> contexts = default)
        {
            contexts ??= new ChangeTrackingList<SummaryContext>();

            return new AbstractiveSummary(text, contexts.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The context of the summary. </summary>
        /// <param name="offset"> Start position for the context. Use of different 'stringIndexType' values can affect the offset returned. </param>
        /// <param name="length"> The length of the context. Use of different 'stringIndexType' values can affect the length returned. </param>
        /// <returns> A new <see cref="Text.SummaryContext"/> instance for mocking. </returns>
        public static SummaryContext SummaryContext(int offset = default, int length = default)
        {
            return new SummaryContext(offset, length, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The long running task to be performed by the service on the input documents.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Text.CustomEntitiesLROTask"/>, <see cref="Text.CustomSingleLabelClassificationOperationAction"/>, <see cref="Text.CustomMultiLabelClassificationOperationAction"/>, <see cref="Text.EntityLinkingLROTask"/>, <see cref="Text.EntitiesLROTask"/>, <see cref="Text.HealthcareLROTask"/>, <see cref="Text.KeyPhraseLROTask"/>, <see cref="Text.PiiLROTask"/>, <see cref="Text.SentimentAnalysisOperationAction"/>, <see cref="Text.ExtractiveSummarizationOperationAction"/>, and <see cref="Text.AbstractiveSummarizationOperationAction"/>.
        /// </summary>
        /// <param name="name"> task name. </param>
        /// <param name="kind"> The kind of task to perform. </param>
        /// <returns> A new <see cref="Text.AnalyzeTextOperationAction"/> instance for mocking. </returns>
        public static AnalyzeTextOperationAction AnalyzeTextOperationAction(string name = default, string kind = default)
        {
            return new UnknownAnalyzeTextOperationAction(name, new AnalyzeTextOperationActionKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the custom text LRO task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> task parameters. </param>
        /// <returns> A new <see cref="Text.CustomEntitiesLROTask"/> instance for mocking. </returns>
        public static CustomEntitiesLROTask CustomEntitiesLROTask(string name = default, CustomEntitiesActionContent parameters = default)
        {
            return new CustomEntitiesLROTask(name, AnalyzeTextOperationActionKind.CustomEntityRecognition, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> Supported parameters for a Custom Entities task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="projectName"> This field indicates the project name for the model. </param>
        /// <param name="deploymentName"> This field indicates the deployment name for the model. </param>
        /// <param name="stringIndexType"> Optional parameter to provide the string index type used to interpret string offsets. Defaults to TextElements (Graphemes). </param>
        /// <returns> A new <see cref="Text.CustomEntitiesActionContent"/> instance for mocking. </returns>
        public static CustomEntitiesActionContent CustomEntitiesActionContent(bool? loggingOptOut = default, string projectName = default, string deploymentName = default, StringIndexType? stringIndexType = default)
        {
            return new CustomEntitiesActionContent(loggingOptOut, projectName, deploymentName, stringIndexType, additionalBinaryDataProperties: null);
        }

        /// <summary> Use custom models to classify text into single label taxonomy. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="actionContent"> Task parameters. </param>
        /// <returns> A new <see cref="Text.CustomSingleLabelClassificationOperationAction"/> instance for mocking. </returns>
        public static CustomSingleLabelClassificationOperationAction CustomSingleLabelClassificationOperationAction(string name = default, CustomSingleLabelClassificationActionContent actionContent = default)
        {
            return new CustomSingleLabelClassificationOperationAction(name, AnalyzeTextOperationActionKind.CustomSingleLabelClassification, additionalBinaryDataProperties: null, actionContent);
        }

        /// <summary> Supported parameters for a Custom Single Classification task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="projectName"> This field indicates the project name for the model. </param>
        /// <param name="deploymentName"> This field indicates the deployment name for the model. </param>
        /// <returns> A new <see cref="Text.CustomSingleLabelClassificationActionContent"/> instance for mocking. </returns>
        public static CustomSingleLabelClassificationActionContent CustomSingleLabelClassificationActionContent(bool? loggingOptOut = default, string projectName = default, string deploymentName = default)
        {
            return new CustomSingleLabelClassificationActionContent(loggingOptOut, projectName, deploymentName, additionalBinaryDataProperties: null);
        }

        /// <summary> Use custom models to classify text into multi label taxonomy. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="actionContent"> Task parameters. </param>
        /// <returns> A new <see cref="Text.CustomMultiLabelClassificationOperationAction"/> instance for mocking. </returns>
        public static CustomMultiLabelClassificationOperationAction CustomMultiLabelClassificationOperationAction(string name = default, CustomMultiLabelClassificationActionContent actionContent = default)
        {
            return new CustomMultiLabelClassificationOperationAction(name, AnalyzeTextOperationActionKind.CustomMultiLabelClassification, additionalBinaryDataProperties: null, actionContent);
        }

        /// <summary> Supported parameters for a Custom Multi Classification task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="projectName"> This field indicates the project name for the model. </param>
        /// <param name="deploymentName"> This field indicates the deployment name for the model. </param>
        /// <returns> A new <see cref="Text.CustomMultiLabelClassificationActionContent"/> instance for mocking. </returns>
        public static CustomMultiLabelClassificationActionContent CustomMultiLabelClassificationActionContent(bool? loggingOptOut = default, string projectName = default, string deploymentName = default)
        {
            return new CustomMultiLabelClassificationActionContent(loggingOptOut, projectName, deploymentName, additionalBinaryDataProperties: null);
        }

        /// <summary> Contains the analyze text Entity linking LRO task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> Task parameters. </param>
        /// <returns> A new <see cref="Text.EntityLinkingLROTask"/> instance for mocking. </returns>
        public static EntityLinkingLROTask EntityLinkingLROTask(string name = default, EntityLinkingActionContent parameters = default)
        {
            return new EntityLinkingLROTask(name, AnalyzeTextOperationActionKind.EntityLinking, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> An object representing the task definition for an Entities Recognition task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> Task parameters. </param>
        /// <returns> A new <see cref="Text.EntitiesLROTask"/> instance for mocking. </returns>
        public static EntitiesLROTask EntitiesLROTask(string name = default, EntitiesActionContent parameters = default)
        {
            return new EntitiesLROTask(name, AnalyzeTextOperationActionKind.EntityRecognition, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> The long running task to be performed by the service on the Healthcare input documents. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> Parameters for the Healthcare task. </param>
        /// <returns> A new <see cref="Text.HealthcareLROTask"/> instance for mocking. </returns>
        public static HealthcareLROTask HealthcareLROTask(string name = default, HealthcareTaskParameters parameters = default)
        {
            return new HealthcareLROTask(name, AnalyzeTextOperationActionKind.Healthcare, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> Supported parameters for a Healthcare task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. </param>
        /// <param name="fhirVersion"> The FHIR Spec version that the result will use to format the fhirBundle. For additional information see https://www.hl7.org/fhir/overview.html. </param>
        /// <param name="documentType"> Document type that can be provided as input for Fhir Documents. Expect to have fhirVersion provided when used. Behavior of using None enum is the same as not using the documentType parameter. </param>
        /// <returns> A new <see cref="Text.HealthcareTaskParameters"/> instance for mocking. </returns>
        public static HealthcareTaskParameters HealthcareTaskParameters(bool? loggingOptOut = default, string modelVersion = default, StringIndexType? stringIndexType = default, FhirVersion? fhirVersion = default, HealthcareDocumentType? documentType = default)
        {
            return new HealthcareTaskParameters(
                loggingOptOut,
                modelVersion,
                stringIndexType,
                fhirVersion,
                documentType,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the task definition for a Key Phrase Extraction task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> Key phrase extraction task parameters. </param>
        /// <returns> A new <see cref="Text.KeyPhraseLROTask"/> instance for mocking. </returns>
        public static KeyPhraseLROTask KeyPhraseLROTask(string name = default, KeyPhraseActionContent parameters = default)
        {
            return new KeyPhraseLROTask(name, AnalyzeTextOperationActionKind.KeyPhraseExtraction, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> Contains the analyze text PIIEntityRecognition LRO task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> Pii task parameters. </param>
        /// <returns> A new <see cref="Text.PiiLROTask"/> instance for mocking. </returns>
        public static PiiLROTask PiiLROTask(string name = default, PiiActionContent parameters = default)
        {
            return new PiiLROTask(name, AnalyzeTextOperationActionKind.PiiEntityRecognition, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> An object representing the task definition for a Sentiment Analysis task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="parameters"> Parameters for the Sentiment Analysis task. </param>
        /// <returns> A new <see cref="Text.SentimentAnalysisOperationAction"/> instance for mocking. </returns>
        public static SentimentAnalysisOperationAction SentimentAnalysisOperationAction(string name = default, SentimentAnalysisActionContent parameters = default)
        {
            return new SentimentAnalysisOperationAction(name, AnalyzeTextOperationActionKind.SentimentAnalysis, additionalBinaryDataProperties: null, parameters);
        }

        /// <summary> An object representing the task definition for an Extractive Summarization task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="actionContent"> Parameters for the Extractive Summarization task. </param>
        /// <returns> A new <see cref="Text.ExtractiveSummarizationOperationAction"/> instance for mocking. </returns>
        public static ExtractiveSummarizationOperationAction ExtractiveSummarizationOperationAction(string name = default, ExtractiveSummarizationActionContent actionContent = default)
        {
            return new ExtractiveSummarizationOperationAction(name, AnalyzeTextOperationActionKind.ExtractiveSummarization, additionalBinaryDataProperties: null, actionContent);
        }

        /// <summary> Supported parameters for an Extractive Summarization task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="sentenceCount"> Specifies the number of sentences in the extracted summary. </param>
        /// <param name="sortBy"> Specifies how to sort the extracted summaries. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. </param>
        /// <param name="query"> (Optional) If provided, the query will be used to extract most relevant sentences from the document. </param>
        /// <returns> A new <see cref="Text.ExtractiveSummarizationActionContent"/> instance for mocking. </returns>
        public static ExtractiveSummarizationActionContent ExtractiveSummarizationActionContent(bool? loggingOptOut = default, string modelVersion = default, long? sentenceCount = default, ExtractiveSummarizationSortingCriteria? sortBy = default, StringIndexType? stringIndexType = default, string query = default)
        {
            return new ExtractiveSummarizationActionContent(
                loggingOptOut,
                modelVersion,
                sentenceCount,
                sortBy,
                stringIndexType,
                query,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the task definition for an Abstractive Summarization task. </summary>
        /// <param name="name"> task name. </param>
        /// <param name="actionContent"> Parameters for the Abstractive Summarization task. </param>
        /// <returns> A new <see cref="Text.AbstractiveSummarizationOperationAction"/> instance for mocking. </returns>
        public static AbstractiveSummarizationOperationAction AbstractiveSummarizationOperationAction(string name = default, AbstractiveSummarizationActionContent actionContent = default)
        {
            return new AbstractiveSummarizationOperationAction(name, AnalyzeTextOperationActionKind.AbstractiveSummarization, additionalBinaryDataProperties: null, actionContent);
        }

        /// <summary> Supported parameters for the pre-built Abstractive Summarization task. </summary>
        /// <param name="loggingOptOut"> logging opt out. </param>
        /// <param name="modelVersion"> model version. </param>
        /// <param name="sentenceCount"> Controls the approximate number of sentences in the output summaries. </param>
        /// <param name="stringIndexType"> String index type. </param>
        /// <param name="summaryLength"> (NOTE: Recommended to use summaryLength over sentenceCount) Controls the approximate length of the output summaries. </param>
        /// <param name="instruction"> (Optional) If provided, the query will be used to generate the summary. </param>
        /// <returns> A new <see cref="Text.AbstractiveSummarizationActionContent"/> instance for mocking. </returns>
        public static AbstractiveSummarizationActionContent AbstractiveSummarizationActionContent(bool? loggingOptOut = default, string modelVersion = default, int? sentenceCount = default, StringIndexType? stringIndexType = default, SummaryLengthBucket? summaryLength = default, string instruction = default)
        {
            return new AbstractiveSummarizationActionContent(
                loggingOptOut,
                modelVersion,
                sentenceCount,
                stringIndexType,
                summaryLength,
                instruction,
                additionalBinaryDataProperties: null);
        }
    }
}
